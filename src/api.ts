/* tslint:disable */
/* eslint-disable */
/**
 * SamCart Public API
 *  # Introduction Welcome to SamCart\'s Public API. This API is used for accessing the data inside your SamCart marketplace. ## Private Beta This API is currently in private beta. If you would like to be considered for our beta program, please contact support@samcart.com. ## OpenAPI Specification This API is documented in OpenAPI format and follows the practices of that specification. # Authentication This API offers one form of authentication: <ul> <li>API Key</lil> </ul>  API keys can only be generated by the SamCart Support team. Please contact support@samcart.com if you would like to be included in the Beta program.  ## Using the API Key To be successfully authenticated, you must pass the header parameter <span class=\'code\'>sc-api</span> with your provided API key. If your key is invalid or not supplied in the call, the API will return code <span class=\'code\'>401 Unauthorized</a> with an additional message explaining the specifics of why that code was returned. ## Security Scheme All of our responses are secure via HTTPS.  This API will accept HTTPS or HTTP requests, but HTTP requests will result in a `301 Moved Permanently` response header to redirect the request to HTTPS. If you send an HTTP request, and your client supports automatic redirects, you will receive your payload back via HTTPS. If your client does not support automatic redirects, you will receive the response `301 Moved Permanently` and you will have to manually update your request to use HTTPS.  # Rate Limiting All endpoints of this API are rate-limited. If any of the limits configured is reached, the service will return status code <span class=\'code\'>429 Too Many Requests</span> to the client. If a request is rate-limited, the response will include a header explaining the limits and how many seconds are remaining before additional requests can be made. # Pagination The following bulk endpoints include pagination: <ul class=\'list\'> <li><a href=\'https://developer.samcart.com/#operation/getCharges\'>Charges</a></li> <li><a href=\'https://developer.samcart.com/#operation/getCustomers\'>Customers</a></li> <li><a href=\'https://developer.samcart.com/#operation/getProducts\'>Products</a></li> </ul>  When making a request to a paginated endpoint, the response will return a maximum of 100 results but can be adjusted using the <span class=\'code\'>limit</span> query parameter. Included in the body of the response are links to subsequent pages of results. Using these links you are able to use to iterate through the various pages of results. # Response Codes The following is a list of the response code that may be sent after an API request is made. Some response codes will provide additional messaging about why that response code was returned: <ul class=\'list\'> <li class=\'code\'>200 Success</li> <li class=\'code\'>301 Moved Permanently</li> <li class=\'code\'>404 Object could not be found</splian> <li class=\'code\'>401 Unauthorized</li> <li class=\'code\'>429 Too Many Requests</li> <li class=\'code\'>504 Timeout</li> </ul>  # Versioning and compatibility We will try to maintain backward and future compatibility as much as we can. However, in case we need to introduce a backward-incompatible change, we will release a new version of the API. Currently, the API is on <span class=\'code\'>Version 1</span>. ## Changelog ### 2021-07-15 Fixed pagination URL protocol to match original request. ### 2021-07-13 Added bulk endpoint for our Subscriptions object. Calls made to this endpoint will return all Subscriptions within the specified parameters. ### 2021-06-22 Added bulk endpoint for our Orders object. Calls made to this endpoint will return all Orders within the specified parameters. ### 2021-06-09 Introduced the <span class=\'code\'>SKU</span> property to the Orders, Subscriptions, and Products endpoint. Added indexes to improve performance. ### 2021-06-02 Initial API specification published and began private beta. # Feedback We’d love your feedback! We’re committed to growing our API product and want to ensure it meets your needs. Click on the link below to give us feedback on our API. While you’re there, check out the other great initiatives on our roadmap. <a href=\'https://feedback.samcart.com/c/85-public-api\'>SamCart Public API Feedback</a> 
 *
 * The version of the OpenAPI document: 1.0.0
 * Contact: support@samcart.com
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


import { Configuration } from './configuration';
import globalAxios, { AxiosPromise, AxiosInstance, AxiosRequestConfig } from 'axios';
// Some imports not used depending on template conditions
// @ts-ignore
import { DUMMY_BASE_URL, assertParamExists, setApiKeyToObject, setBasicAuthToObject, setBearerAuthToObject, setOAuthToObject, setSearchParams, serializeDataIfNeeded, toPathString, createRequestFunction } from './common';
// @ts-ignore
import { BASE_PATH, COLLECTION_FORMATS, RequestArgs, BaseAPI, RequiredError } from './base';

/**
 * Address
 * @export
 * @interface AddressService
 */
export interface AddressService {
    /**
     * The type of address for the customer
     * @type {string}
     * @memberof AddressService
     */
    'type'?: AddressServiceTypeEnum;
    /**
     * The street for the customer
     * @type {string}
     * @memberof AddressService
     */
    'street'?: string;
    /**
     * The postal code for the customer
     * @type {string}
     * @memberof AddressService
     */
    'postal_code'?: string;
    /**
     * The city name for the customer
     * @type {string}
     * @memberof AddressService
     */
    'city'?: string;
    /**
     * The 2-letter state code for US customers. For non-US addresses this value will be null.
     * @type {string}
     * @memberof AddressService
     */
    'state'?: string | null;
    /**
     * The optional sub-divided area of a country for international customers. For US addresses this value will be null.
     * @type {string}
     * @memberof AddressService
     */
    'region'?: string | null;
    /**
     * The country for the customer
     * @type {string}
     * @memberof AddressService
     */
    'country'?: string;
}

export const AddressServiceTypeEnum = {
    Shipping: 'shipping',
    Billing: 'billing'
} as const;

export type AddressServiceTypeEnum = typeof AddressServiceTypeEnum[keyof typeof AddressServiceTypeEnum];

/**
 * Charge
 * @export
 * @interface ChargeService
 */
export interface ChargeService {
    /**
     * The SamCart ID for the charge
     * @type {number}
     * @memberof ChargeService
     */
    'id'?: number;
    /**
     * The SamCart ID for the customer that created the charge
     * @type {number}
     * @memberof ChargeService
     */
    'customer_id'?: number;
    /**
     * The SamCart ID of the affiliate credited for the order
     * @type {number}
     * @memberof ChargeService
     */
    'affiliate_id'?: number | null;
    /**
     * The SamCart ID for the order. For subscriptions, this will be the order ID of the original purchase
     * @type {number}
     * @memberof ChargeService
     */
    'order_id'?: number;
    /**
     * The SamCart ID for the subscription rebill. If the charge is for a non-subscription product, this will be null.
     * @type {number}
     * @memberof ChargeService
     */
    'subscription_rebill_id'?: number | null;
    /**
     * Indicates whether the transaction was done while the product was in test mode
     * @type {boolean}
     * @memberof ChargeService
     */
    'test_mode'?: boolean;
    /**
     * The name of the processor for the order
     * @type {string}
     * @memberof ChargeService
     */
    'processor_name'?: ChargeServiceProcessorNameEnum;
    /**
     * The processor ID generated for the charge
     * @type {string}
     * @memberof ChargeService
     */
    'processor_transaction_id'?: string;
    /**
     * The 3 letter identifier for the currency for the charge
     * @type {string}
     * @memberof ChargeService
     */
    'currency'?: string;
    /**
     * The last 4 digits of the card that was used. PayPal charges will have a null value.
     * @type {number}
     * @memberof ChargeService
     */
    'card_used'?: number | null;
    /**
     * Indicates whether a refund and the type of refund. If no refund was created the value will be null.
     * @type {string}
     * @memberof ChargeService
     */
    'charge_refund_status'?: ChargeServiceChargeRefundStatusEnum;
    /**
     * The UTC date and time for when the order was created
     * @type {string}
     * @memberof ChargeService
     */
    'order_date'?: string;
    /**
     * The UTC date and time that the charge was created
     * @type {string}
     * @memberof ChargeService
     */
    'created_at'?: string;
    /**
     * The total (in cents) for the charge including taxes and shipping fees
     * @type {number}
     * @memberof ChargeService
     */
    'total'?: number;
}

export const ChargeServiceProcessorNameEnum = {
    Stripe: 'Stripe',
    Braintree: 'Braintree',
    AuthorizeNet: 'Authorize.net',
    PayPal: 'PayPal'
} as const;

export type ChargeServiceProcessorNameEnum = typeof ChargeServiceProcessorNameEnum[keyof typeof ChargeServiceProcessorNameEnum];
export const ChargeServiceChargeRefundStatusEnum = {
    Refunded: 'refunded',
    PartiallyRefunded: 'partially_refunded'
} as const;

export type ChargeServiceChargeRefundStatusEnum = typeof ChargeServiceChargeRefundStatusEnum[keyof typeof ChargeServiceChargeRefundStatusEnum];

/**
 * Customer
 * @export
 * @interface CustomerService
 */
export interface CustomerService {
    /**
     * The SamCart ID of the customer
     * @type {number}
     * @memberof CustomerService
     */
    'id'?: number;
    /**
     * The first name of the customer
     * @type {string}
     * @memberof CustomerService
     */
    'first_name'?: string | null;
    /**
     * The last name of the customer
     * @type {string}
     * @memberof CustomerService
     */
    'last_name'?: string | null;
    /**
     * The email address of the customer
     * @type {string}
     * @memberof CustomerService
     */
    'email'?: string;
    /**
     * The phone number of the customer
     * @type {string}
     * @memberof CustomerService
     */
    'phone'?: string | null;
    /**
     * The tags applied to the customer
     * @type {Array<CustomerServiceCustomerTags>}
     * @memberof CustomerService
     */
    'customer_tags'?: Array<CustomerServiceCustomerTags>;
    /**
     * The lifetime value (in cents) of the customer. Value is for live data only
     * @type {number}
     * @memberof CustomerService
     */
    'lifetime_value'?: number;
    /**
     * The UTC date and time when the customer information was updated
     * @type {string}
     * @memberof CustomerService
     */
    'updated_at'?: string;
    /**
     * The UTC date and time when the customer was created
     * @type {string}
     * @memberof CustomerService
     */
    'created_at'?: string;
    /**
     * Addresses associated with the customer
     * @type {Array<AddressService>}
     * @memberof CustomerService
     */
    'addresses'?: Array<AddressService>;
}
/**
 * 
 * @export
 * @interface CustomerServiceCustomerTags
 */
export interface CustomerServiceCustomerTags {
    /**
     * The name of the customer tag
     * @type {string}
     * @memberof CustomerServiceCustomerTags
     */
    'name'?: string;
}
/**
 * Failed Charge
 * @export
 * @interface FailedChargeService
 */
export interface FailedChargeService {
    /**
     * The SamCart ID for the charge
     * @type {number}
     * @memberof FailedChargeService
     */
    'id'?: number;
    /**
     * The SamCart ID for the customer that created the charge
     * @type {number}
     * @memberof FailedChargeService
     */
    'customer_id'?: number | null;
    /**
     * The SamCart ID of the affiliate credited for the order
     * @type {number}
     * @memberof FailedChargeService
     */
    'affiliate_id'?: number | null;
    /**
     * The SamCart ID for the order. For subscriptions, this will be the order ID of the original purchase
     * @type {number}
     * @memberof FailedChargeService
     */
    'order_id'?: number | null;
    /**
     * The SamCart ID for the subscription rebill. If the charge is for a non-subscription product, this will be null.
     * @type {number}
     * @memberof FailedChargeService
     */
    'subscription_rebill_id'?: number | null;
    /**
     * Indicates whether the transaction was done while the product was in test mode
     * @type {boolean}
     * @memberof FailedChargeService
     */
    'test_mode'?: boolean;
    /**
     * The name of the processor for the order
     * @type {string}
     * @memberof FailedChargeService
     */
    'processor_name'?: FailedChargeServiceProcessorNameEnum;
    /**
     * The processor ID generated for the charge
     * @type {string}
     * @memberof FailedChargeService
     */
    'processor_transaction_id'?: string;
    /**
     * The error message provided by the payment processor
     * @type {string}
     * @memberof FailedChargeService
     */
    'error'?: string | null;
    /**
     * The 3 letter identifier for the currency for the charge
     * @type {string}
     * @memberof FailedChargeService
     */
    'currency'?: string;
    /**
     * The last 4 digits of the card that was used. PayPal charges will have a null value.
     * @type {number}
     * @memberof FailedChargeService
     */
    'card_used'?: number | null;
    /**
     * The UTC date and time that the charge was created
     * @type {string}
     * @memberof FailedChargeService
     */
    'created_at'?: string;
    /**
     * The total (in cents) for the charge including taxes and shipping fees
     * @type {number}
     * @memberof FailedChargeService
     */
    'total'?: number;
}

export const FailedChargeServiceProcessorNameEnum = {
    Stripe: 'Stripe',
    Braintree: 'Braintree',
    AuthorizeNet: 'Authorize.net',
    PayPal: 'PayPal'
} as const;

export type FailedChargeServiceProcessorNameEnum = typeof FailedChargeServiceProcessorNameEnum[keyof typeof FailedChargeServiceProcessorNameEnum];

/**
 * 
 * @export
 * @interface InlineResponse200
 */
export interface InlineResponse200 {
    /**
     * 
     * @type {Array<ChargeService>}
     * @memberof InlineResponse200
     */
    'data'?: Array<ChargeService>;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse200
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2001
 */
export interface InlineResponse2001 {
    /**
     * 
     * @type {Array<CustomerService>}
     * @memberof InlineResponse2001
     */
    'data'?: Array<CustomerService>;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2001
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2002
 */
export interface InlineResponse2002 {
    /**
     * 
     * @type {Array<FailedChargeService>}
     * @memberof InlineResponse2002
     */
    'data'?: Array<FailedChargeService>;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2002
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2003
 */
export interface InlineResponse2003 {
    /**
     * 
     * @type {Array<OrderService>}
     * @memberof InlineResponse2003
     */
    'data'?: Array<OrderService>;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2003
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2004
 */
export interface InlineResponse2004 {
    /**
     * 
     * @type {Array<ProductService>}
     * @memberof InlineResponse2004
     */
    'data'?: Array<ProductService>;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2004
     */
    'pagination'?: Pagination;
}
/**
 * 
 * @export
 * @interface InlineResponse2005
 */
export interface InlineResponse2005 {
    /**
     * 
     * @type {Array<SubscriptionService>}
     * @memberof InlineResponse2005
     */
    'data'?: Array<SubscriptionService>;
    /**
     * 
     * @type {Pagination}
     * @memberof InlineResponse2005
     */
    'pagination'?: Pagination;
}
/**
 * Order
 * @export
 * @interface OrderService
 */
export interface OrderService {
    /**
     * The SamCart ID of the order
     * @type {number}
     * @memberof OrderService
     */
    'id'?: number;
    /**
     * The SamCart ID of the customer
     * @type {number}
     * @memberof OrderService
     */
    'customer_id'?: number;
    /**
     * The SamCart ID of the affiliate credited for the order
     * @type {number}
     * @memberof OrderService
     */
    'affiliate_id'?: number | null;
    /**
     * Indicates whether the transaction was done while the product was in test mode
     * @type {boolean}
     * @memberof OrderService
     */
    'test_mode'?: boolean;
    /**
     * The UTC date and time for when the order was created
     * @type {string}
     * @memberof OrderService
     */
    'order_date'?: string;
    /**
     * A list of cart items on the order
     * @type {Array<OrderServiceCartItems>}
     * @memberof OrderService
     */
    'cart_items'?: Array<OrderServiceCartItems>;
    /**
     * The total price of the order (in cents) excluding discount, shipping and tax fees
     * @type {number}
     * @memberof OrderService
     */
    'subtotal'?: number;
    /**
     * The total discount (in cents) on the order
     * @type {number}
     * @memberof OrderService
     */
    'discount'?: number;
    /**
     * The total of tax fees (in cents) of the order
     * @type {number}
     * @memberof OrderService
     */
    'taxes'?: number;
    /**
     * The total of shipping fees (in cents) of the order
     * @type {number}
     * @memberof OrderService
     */
    'shipping'?: number;
    /**
     * The total price of the order (in cents) including discount, shipping and tax fees
     * @type {number}
     * @memberof OrderService
     */
    'total'?: number;
    /**
     * The last 4 digits of the card that was used. PayPal charges will have a null value.
     * @type {string}
     * @memberof OrderService
     */
    'card_used'?: string | null;
    /**
     * The name of the processor for the order
     * @type {string}
     * @memberof OrderService
     */
    'processor_name'?: OrderServiceProcessorNameEnum;
    /**
     * Optional custom fields applied to the order
     * @type {object}
     * @memberof OrderService
     */
    'custom_fields'?: object;
}

export const OrderServiceProcessorNameEnum = {
    Stripe: 'Stripe',
    Braintree: 'Braintree',
    AuthorizeNet: 'Authorize.net',
    PayPal: 'PayPal'
} as const;

export type OrderServiceProcessorNameEnum = typeof OrderServiceProcessorNameEnum[keyof typeof OrderServiceProcessorNameEnum];

/**
 * 
 * @export
 * @interface OrderServiceCartItems
 */
export interface OrderServiceCartItems {
    /**
     * The ID for the specific cart item
     * @type {number}
     * @memberof OrderServiceCartItems
     */
    'id'?: number;
    /**
     * The SamCart ID for the product
     * @type {number}
     * @memberof OrderServiceCartItems
     */
    'product_id'?: number;
    /**
     * The subscription ID for the product. If the cart item is for a non-subscription product the value will be null
     * @type {number}
     * @memberof OrderServiceCartItems
     */
    'subscription_id'?: number | null;
    /**
     * The optional product SKU of the cart item purchased
     * @type {string}
     * @memberof OrderServiceCartItems
     */
    'sku'?: string | null;
    /**
     * An optional product name displayed on the marketplace dashboard
     * @type {string}
     * @memberof OrderServiceCartItems
     */
    'internal_product_name'?: string | null;
    /**
     * The product name displayed to customers
     * @type {string}
     * @memberof OrderServiceCartItems
     */
    'product_name'?: string;
    /**
     * The SamCart ID for the charge
     * @type {number}
     * @memberof OrderServiceCartItems
     */
    'charge_id'?: number;
    /**
     * Indicates how the product is priced
     * @type {string}
     * @memberof OrderServiceCartItems
     */
    'pricing_type'?: OrderServiceCartItemsPricingTypeEnum;
    /**
     * The processor ID generated for the charge
     * @type {string}
     * @memberof OrderServiceCartItems
     */
    'processor_transaction_id'?: string;
    /**
     * The 3 letter identifier for the currency for the charge on the cart item
     * @type {string}
     * @memberof OrderServiceCartItems
     */
    'currency'?: string;
    /**
     * The quantity of the cart item purchased
     * @type {number}
     * @memberof OrderServiceCartItems
     */
    'quantity'?: number;
    /**
     * The current status of the charge on the cart item
     * @type {string}
     * @memberof OrderServiceCartItems
     */
    'status'?: OrderServiceCartItemsStatusEnum;
    /**
     * 
     * @type {OrderServiceInitialPrice}
     * @memberof OrderServiceCartItems
     */
    'initial_price'?: OrderServiceInitialPrice;
    /**
     * 
     * @type {OrderServiceRecurringPrice}
     * @memberof OrderServiceCartItems
     */
    'recurring_price'?: OrderServiceRecurringPrice;
    /**
     * 
     * @type {OrderServiceCoupon}
     * @memberof OrderServiceCartItems
     */
    'coupon'?: OrderServiceCoupon;
}

export const OrderServiceCartItemsPricingTypeEnum = {
    OneTime: 'one_time',
    RecurringSubscription: 'recurring_subscription',
    LimitedSubscription: 'limited_subscription',
    PwywOnetime: 'pwyw_onetime',
    PwywRecurringSubscription: 'pwyw_recurring_subscription',
    PwywLimitedSubscription: 'pwyw_limited_subscription'
} as const;

export type OrderServiceCartItemsPricingTypeEnum = typeof OrderServiceCartItemsPricingTypeEnum[keyof typeof OrderServiceCartItemsPricingTypeEnum];
export const OrderServiceCartItemsStatusEnum = {
    Pending: 'pending',
    Charged: 'charged',
    Declined: 'declined',
    Refunded: 'refunded',
    Fulfilled: 'fulfilled',
    Reversed: 'reversed',
    PartiallyRefunded: 'partially_refunded'
} as const;

export type OrderServiceCartItemsStatusEnum = typeof OrderServiceCartItemsStatusEnum[keyof typeof OrderServiceCartItemsStatusEnum];

/**
 * An optional coupon that was applied to the cart item
 * @export
 * @interface OrderServiceCoupon
 */
export interface OrderServiceCoupon {
    /**
     * The ID of the coupon that was used on the cart item
     * @type {number}
     * @memberof OrderServiceCoupon
     */
    'id'?: number;
    /**
     * Whether the coupon applies only once or for recurring charges also
     * @type {string}
     * @memberof OrderServiceCoupon
     */
    'charge_instance'?: OrderServiceCouponChargeInstanceEnum;
    /**
     * The code of the coupon used
     * @type {string}
     * @memberof OrderServiceCoupon
     */
    'code'?: string;
    /**
     * The type of discount applied
     * @type {string}
     * @memberof OrderServiceCoupon
     */
    'type'?: OrderServiceCouponTypeEnum;
    /**
     * The flat_rate discount amount (in cents) on the cart item
     * @type {number}
     * @memberof OrderServiceCoupon
     */
    'discount_amount'?: number | null;
    /**
     * The percentage discount on the cart item
     * @type {number}
     * @memberof OrderServiceCoupon
     */
    'discount_percentage'?: number | null;
}

export const OrderServiceCouponChargeInstanceEnum = {
    OneTime: 'one_time',
    Recurring: 'recurring'
} as const;

export type OrderServiceCouponChargeInstanceEnum = typeof OrderServiceCouponChargeInstanceEnum[keyof typeof OrderServiceCouponChargeInstanceEnum];
export const OrderServiceCouponTypeEnum = {
    FlatRate: 'flat_rate',
    Percentage: 'percentage'
} as const;

export type OrderServiceCouponTypeEnum = typeof OrderServiceCouponTypeEnum[keyof typeof OrderServiceCouponTypeEnum];

/**
 * The pricing structure for one-time purchases and for the first charge on subscription products
 * @export
 * @interface OrderServiceInitialPrice
 */
export interface OrderServiceInitialPrice {
    /**
     * The price for the cart item (in cents) excluding discount, taxes and shipping fees
     * @type {number}
     * @memberof OrderServiceInitialPrice
     */
    'subtotal'?: number;
    /**
     * The tax fees (in cents) for the cart item
     * @type {number}
     * @memberof OrderServiceInitialPrice
     */
    'taxes'?: number;
    /**
     * The shipping fees (in cents) for the cart item
     * @type {number}
     * @memberof OrderServiceInitialPrice
     */
    'shipping'?: number;
    /**
     * The price for the cart item (in cents) including discount, taxes and shipping fees
     * @type {number}
     * @memberof OrderServiceInitialPrice
     */
    'total'?: number;
}
/**
 * The pricing structure for limited and recurring subscription products. This structure could differ from the initial price.
 * @export
 * @interface OrderServiceRecurringPrice
 */
export interface OrderServiceRecurringPrice {
    /**
     * The recurring price for the cart item (in cents) excluding discount, taxes and shipping fees
     * @type {number}
     * @memberof OrderServiceRecurringPrice
     */
    'subtotal'?: number;
    /**
     * The recurring tax fees (in cents) for the cart item
     * @type {number}
     * @memberof OrderServiceRecurringPrice
     */
    'taxes'?: number;
    /**
     * The recurring shipping fees (in cents) for the cart item
     * @type {number}
     * @memberof OrderServiceRecurringPrice
     */
    'shipping'?: number;
    /**
     * The recurring price for the cart item (in cents) including discount, taxes and shipping fees
     * @type {number}
     * @memberof OrderServiceRecurringPrice
     */
    'total'?: number;
}
/**
 * Optional information for paginating large data sets.
 * @export
 * @interface Pagination
 */
export interface Pagination {
    /**
     * A URL to the next page of data to be retrieve. If current page is the last page this value will be null.
     * @type {string}
     * @memberof Pagination
     */
    'next'?: string | null;
    /**
     * A URL to the previous page of data to be retrieve. If current page is the first page this value will be null.
     * @type {string}
     * @memberof Pagination
     */
    'prev'?: string | null;
}
/**
 * Product
 * @export
 * @interface ProductService
 */
export interface ProductService {
    /**
     * The SamCart ID of the product
     * @type {number}
     * @memberof ProductService
     */
    'id'?: number;
    /**
     * An optional product SKU displayed on the marketplace dashboard
     * @type {string}
     * @memberof ProductService
     */
    'sku'?: string | null;
    /**
     * An optional product name displayed on the marketplace dashboard
     * @type {string}
     * @memberof ProductService
     */
    'internal_product_name'?: string | null;
    /**
     * The product name displayed to customers
     * @type {string}
     * @memberof ProductService
     */
    'product_name'?: string;
    /**
     * The optional description of the product
     * @type {string}
     * @memberof ProductService
     */
    'description'?: string | null;
    /**
     * The 3 letter identifier for the currency currently configured on the product. This can be changed.
     * @type {string}
     * @memberof ProductService
     */
    'currency'?: string;
    /**
     * The price of the product. For subscription products, it is the initial price (in cents)
     * @type {number}
     * @memberof ProductService
     */
    'price'?: number;
    /**
     * Indicates the type of product being sold
     * @type {string}
     * @memberof ProductService
     */
    'product_category'?: ProductServiceProductCategoryEnum;
    /**
     * Indicates how the product will be priced
     * @type {string}
     * @memberof ProductService
     */
    'pricing_type'?: ProductServicePricingTypeEnum;
    /**
     * Indicates the current status of the product
     * @type {string}
     * @memberof ProductService
     */
    'status'?: ProductServiceStatusEnum;
    /**
     * Indicates if the product is currently configured to have taxes. This can be changed.
     * @type {boolean}
     * @memberof ProductService
     */
    'taxes'?: boolean;
    /**
     * The name of the upsell funnel attached to the product
     * @type {string}
     * @memberof ProductService
     */
    'upsell_funnel'?: string | null;
    /**
     * An optional list of additional products added with the product before checkout
     * @type {Array<ProductServiceOrderBumps>}
     * @memberof ProductService
     */
    'order_bumps'?: Array<ProductServiceOrderBumps>;
    /**
     * An optional list of products bundled to the product
     * @type {Array<ProductServiceBundledProducts>}
     * @memberof ProductService
     */
    'bundled_products'?: Array<ProductServiceBundledProducts>;
    /**
     * The URL slug for the product
     * @type {string}
     * @memberof ProductService
     */
    'slug'?: string;
    /**
     * An optional custom domain used for the product
     * @type {string}
     * @memberof ProductService
     */
    'custom_domain'?: string | null;
    /**
     * An optional list of product tags
     * @type {Array<ProductServiceProductTags>}
     * @memberof ProductService
     */
    'product_tags'?: Array<ProductServiceProductTags>;
    /**
     * The UTC date and time the product was created
     * @type {string}
     * @memberof ProductService
     */
    'created_at'?: string;
    /**
     * The UTC date and time the product was updated
     * @type {string}
     * @memberof ProductService
     */
    'updated_at'?: string;
    /**
     * The UTC date and time the product was archived. If the product has not been archive the value will be null.
     * @type {string}
     * @memberof ProductService
     */
    'archived_date'?: string | null;
}

export const ProductServiceProductCategoryEnum = {
    Physical: 'physical',
    Digital: 'digital'
} as const;

export type ProductServiceProductCategoryEnum = typeof ProductServiceProductCategoryEnum[keyof typeof ProductServiceProductCategoryEnum];
export const ProductServicePricingTypeEnum = {
    OneTime: 'one_time',
    Limited: 'limited',
    Recurring: 'recurring',
    Pwyw: 'pwyw'
} as const;

export type ProductServicePricingTypeEnum = typeof ProductServicePricingTypeEnum[keyof typeof ProductServicePricingTypeEnum];
export const ProductServiceStatusEnum = {
    Live: 'live',
    Test: 'test',
    Archived: 'archived'
} as const;

export type ProductServiceStatusEnum = typeof ProductServiceStatusEnum[keyof typeof ProductServiceStatusEnum];

/**
 * 
 * @export
 * @interface ProductServiceBundledProducts
 */
export interface ProductServiceBundledProducts {
    /**
     * The SamCart ID of the bundled product
     * @type {number}
     * @memberof ProductServiceBundledProducts
     */
    'product_id'?: number;
    /**
     * The bundled product name displayed to customers
     * @type {string}
     * @memberof ProductServiceBundledProducts
     */
    'product_name'?: string;
}
/**
 * 
 * @export
 * @interface ProductServiceOrderBumps
 */
export interface ProductServiceOrderBumps {
    /**
     * The SamCart ID for the additional product
     * @type {number}
     * @memberof ProductServiceOrderBumps
     */
    'product_id'?: number;
    /**
     * The name of the additional product
     * @type {string}
     * @memberof ProductServiceOrderBumps
     */
    'product_name'?: string;
}
/**
 * 
 * @export
 * @interface ProductServiceProductTags
 */
export interface ProductServiceProductTags {
    /**
     * The name of the product tag
     * @type {string}
     * @memberof ProductServiceProductTags
     */
    'name'?: string;
}
/**
 * Refund
 * @export
 * @interface RefundService
 */
export interface RefundService {
    /**
     * The SamCart ID for the refund
     * @type {number}
     * @memberof RefundService
     */
    'id'?: number;
    /**
     * The SamCart ID for the charge
     * @type {number}
     * @memberof RefundService
     */
    'charge_id'?: number;
    /**
     * The ID for the refunded cart item
     * @type {number}
     * @memberof RefundService
     */
    'cart_item_id'?: number;
    /**
     * The UTC date and time the refund was issued
     * @type {string}
     * @memberof RefundService
     */
    'created_at'?: string;
    /**
     * Indicates whether the transaction was done while the transaction was in test mode.
     * @type {boolean}
     * @memberof RefundService
     */
    'test_mode'?: boolean;
    /**
     * Indicates whether a refund and the type of refund. If no refund was created the value will be null.
     * @type {string}
     * @memberof RefundService
     */
    'charge_refund_status'?: RefundServiceChargeRefundStatusEnum;
    /**
     * This will match the currency that the original charge was created in and will be the currency of the created refund
     * @type {string}
     * @memberof RefundService
     */
    'currency'?: string;
    /**
     * The total refund amount (in cents)
     * @type {number}
     * @memberof RefundService
     */
    'refund_amount'?: number;
}

export const RefundServiceChargeRefundStatusEnum = {
    Refunded: 'refunded',
    PartiallyRefunded: 'partially_refunded'
} as const;

export type RefundServiceChargeRefundStatusEnum = typeof RefundServiceChargeRefundStatusEnum[keyof typeof RefundServiceChargeRefundStatusEnum];

/**
 * Subscription History
 * @export
 * @interface SubscriptionHistoryService
 */
export interface SubscriptionHistoryService {
    /**
     * The SamCart ID for the subscription history record
     * @type {number}
     * @memberof SubscriptionHistoryService
     */
    'id'?: number;
    /**
     * The SamCart ID for the subscription
     * @type {number}
     * @memberof SubscriptionHistoryService
     */
    'subscription_id'?: number;
    /**
     * The status of the subscription
     * @type {string}
     * @memberof SubscriptionHistoryService
     */
    'new_status'?: SubscriptionHistoryServiceNewStatusEnum;
    /**
     * The source of the change
     * @type {string}
     * @memberof SubscriptionHistoryService
     */
    'source'?: string;
    /**
     * The type of change
     * @type {string}
     * @memberof SubscriptionHistoryService
     */
    'type'?: string;
    /**
     * The UTC date and time that the change was made
     * @type {string}
     * @memberof SubscriptionHistoryService
     */
    'change_date'?: string;
}

export const SubscriptionHistoryServiceNewStatusEnum = {
    Active: 'active',
    Canceled: 'canceled',
    Delinquent: 'delinquent',
    Completed: 'completed',
    Paused: 'paused',
    InvalidProcessor: 'invalid_processor',
    ScaRequired: 'sca_required',
    Deleted: 'deleted'
} as const;

export type SubscriptionHistoryServiceNewStatusEnum = typeof SubscriptionHistoryServiceNewStatusEnum[keyof typeof SubscriptionHistoryServiceNewStatusEnum];

/**
 * Subscription Plan
 * @export
 * @interface SubscriptionPlanService
 */
export interface SubscriptionPlanService {
    /**
     * The SamCart ID for the subscription plan
     * @type {number}
     * @memberof SubscriptionPlanService
     */
    'id'?: number;
    /**
     * The SamCart ID for the product
     * @type {number}
     * @memberof SubscriptionPlanService
     */
    'product_id'?: number;
    /**
     * The current status of the subscription plan
     * @type {string}
     * @memberof SubscriptionPlanService
     */
    'plan_status'?: SubscriptionPlanServicePlanStatusEnum;
    /**
     * The UTC date and time for when the subscription plan was archived
     * @type {string}
     * @memberof SubscriptionPlanService
     */
    'plan_archived_date'?: string | null;
    /**
     * For a limited subscription, this indicates the number of rebills
     * @type {number}
     * @memberof SubscriptionPlanService
     */
    'plan_duration'?: number;
    /**
     * Indicates how frequently the subscription will rebill
     * @type {string}
     * @memberof SubscriptionPlanService
     */
    'plan_frequency'?: SubscriptionPlanServicePlanFrequencyEnum;
    /**
     * The recurring price of subscription exclusing tax and shipping fees
     * @type {number}
     * @memberof SubscriptionPlanService
     */
    'plan_price'?: number;
    /**
     * The number of days that the subscription has for a trial
     * @type {number}
     * @memberof SubscriptionPlanService
     */
    'trial_period'?: number;
    /**
     * The number of days between each subscription rebill, used for \'days\' frequency only
     * @type {number}
     * @memberof SubscriptionPlanService
     */
    'rebill_days'?: number;
    /**
     * Indicates whether the subscription will be Stripe-managed
     * @type {boolean}
     * @memberof SubscriptionPlanService
     */
    'stripe_compatible'?: boolean;
    /**
     * For Stripe-managed subscriptions, this is the plan ID from within Stripe
     * @type {string}
     * @memberof SubscriptionPlanService
     */
    'stripe_plan_id'?: string | null;
    /**
     * Indicates whether the subscription is associated with a Stripe testing environment
     * @type {boolean}
     * @memberof SubscriptionPlanService
     */
    'on_stripe_sandbox'?: boolean;
    /**
     * Indicates whether the shipping prices for the subscription will be charged at every subscription rebill
     * @type {boolean}
     * @memberof SubscriptionPlanService
     */
    'recurring_shipping'?: boolean;
}

export const SubscriptionPlanServicePlanStatusEnum = {
    Active: 'active',
    Archived: 'archived'
} as const;

export type SubscriptionPlanServicePlanStatusEnum = typeof SubscriptionPlanServicePlanStatusEnum[keyof typeof SubscriptionPlanServicePlanStatusEnum];
export const SubscriptionPlanServicePlanFrequencyEnum = {
    Days: 'days',
    Weekly: 'weekly',
    Monthly: 'monthly',
    Quarterly: 'quarterly',
    Yearly: 'yearly'
} as const;

export type SubscriptionPlanServicePlanFrequencyEnum = typeof SubscriptionPlanServicePlanFrequencyEnum[keyof typeof SubscriptionPlanServicePlanFrequencyEnum];

/**
 * Subscription
 * @export
 * @interface SubscriptionService
 */
export interface SubscriptionService {
    /**
     * The SamCart ID for the subscription
     * @type {number}
     * @memberof SubscriptionService
     */
    'id'?: number;
    /**
     * The SamCart ID for the customer that created the charge
     * @type {number}
     * @memberof SubscriptionService
     */
    'customer_id'?: number;
    /**
     * The SamCart ID of the affiliate credited for the order.
     * @type {number}
     * @memberof SubscriptionService
     */
    'affiliate_id'?: number | null;
    /**
     * The SamCart ID for the order. For subscriptions, this will be the order ID of the original purchase.
     * @type {number}
     * @memberof SubscriptionService
     */
    'order_id'?: number;
    /**
     * The SamCart ID for a product in the cart
     * @type {number}
     * @memberof SubscriptionService
     */
    'product_id'?: number;
    /**
     * The optional product SKU for the subscription
     * @type {string}
     * @memberof SubscriptionService
     */
    'sku'?: string | null;
    /**
     * The status of the subscription
     * @type {string}
     * @memberof SubscriptionService
     */
    'status'?: SubscriptionServiceStatusEnum;
    /**
     * Indicates the format of the subscription
     * @type {string}
     * @memberof SubscriptionService
     */
    'type'?: SubscriptionServiceTypeEnum;
    /**
     * The name of the product for the subscription
     * @type {string}
     * @memberof SubscriptionService
     */
    'product_name'?: string;
    /**
     * An optional product name displayed on the marketplace dashboard for the subscription
     * @type {string}
     * @memberof SubscriptionService
     */
    'internal_product_name'?: string | null;
    /**
     * 
     * @type {SubscriptionServiceInitialPrice}
     * @memberof SubscriptionService
     */
    'initial_price'?: SubscriptionServiceInitialPrice;
    /**
     * 
     * @type {SubscriptionServiceRecurringPrice}
     * @memberof SubscriptionService
     */
    'recurring_price'?: SubscriptionServiceRecurringPrice;
    /**
     * 
     * @type {SubscriptionServiceCoupon}
     * @memberof SubscriptionService
     */
    'coupon'?: SubscriptionServiceCoupon;
    /**
     * The name of the processor for the order
     * @type {string}
     * @memberof SubscriptionService
     */
    'processor_name'?: SubscriptionServiceProcessorNameEnum;
    /**
     * Indicates whether the transaction was done while the product was in test mode.
     * @type {boolean}
     * @memberof SubscriptionService
     */
    'test_mode'?: boolean;
    /**
     * The last 4 digits of the card that was used. PayPal charges will have a null value.
     * @type {number}
     * @memberof SubscriptionService
     */
    'card_used'?: number | null;
    /**
     * The UTC date and time the subscription was created. This is also when the original order was created.
     * @type {string}
     * @memberof SubscriptionService
     */
    'created_at'?: string;
    /**
     * The UTC date and time the first rebill occurred. For subscriptions with trials, this will be the first rebill after the trial.
     * @type {string}
     * @memberof SubscriptionService
     */
    'start_date'?: string;
    /**
     * The UTC date and time that a limited subscription will end. Recurring subscriptions will not have a value.
     * @type {string}
     * @memberof SubscriptionService
     */
    'end_date'?: string | null;
    /**
     * The UTC date and time of the next rebill for the subscription
     * @type {string}
     * @memberof SubscriptionService
     */
    'next_rebilling_date'?: string;
    /**
     * The number of unsuccessful charges for this subscription
     * @type {number}
     * @memberof SubscriptionService
     */
    'total_failed_charges'?: number;
}

export const SubscriptionServiceStatusEnum = {
    Active: 'active',
    Canceled: 'canceled',
    Delinquent: 'delinquent',
    Completed: 'completed',
    Paused: 'paused',
    InvalidProcessor: 'invalid_processor',
    ScaRequired: 'sca_required',
    Deleted: 'deleted'
} as const;

export type SubscriptionServiceStatusEnum = typeof SubscriptionServiceStatusEnum[keyof typeof SubscriptionServiceStatusEnum];
export const SubscriptionServiceTypeEnum = {
    LimitedSubscription: 'limited_subscription',
    RecurringSubscription: 'recurring_subscription'
} as const;

export type SubscriptionServiceTypeEnum = typeof SubscriptionServiceTypeEnum[keyof typeof SubscriptionServiceTypeEnum];
export const SubscriptionServiceProcessorNameEnum = {
    Stripe: 'Stripe',
    Braintree: 'Braintree',
    AuthorizeNet: 'Authorize.net',
    PayPal: 'PayPal'
} as const;

export type SubscriptionServiceProcessorNameEnum = typeof SubscriptionServiceProcessorNameEnum[keyof typeof SubscriptionServiceProcessorNameEnum];

/**
 * An optional coupon that is applied to the subscription rebill
 * @export
 * @interface SubscriptionServiceCoupon
 */
export interface SubscriptionServiceCoupon {
    /**
     * The ID of the coupon that was used on the subscription
     * @type {number}
     * @memberof SubscriptionServiceCoupon
     */
    'id'?: number;
    /**
     * Whether the coupon applies only once or for recurring charges also
     * @type {string}
     * @memberof SubscriptionServiceCoupon
     */
    'charge_instance'?: SubscriptionServiceCouponChargeInstanceEnum;
    /**
     * The code of the coupon used
     * @type {string}
     * @memberof SubscriptionServiceCoupon
     */
    'code'?: string;
    /**
     * The type of discount applied
     * @type {string}
     * @memberof SubscriptionServiceCoupon
     */
    'type'?: SubscriptionServiceCouponTypeEnum;
    /**
     * The flat_rate discount amount (in cents) on the subscription
     * @type {number}
     * @memberof SubscriptionServiceCoupon
     */
    'discount_amount'?: number | null;
    /**
     * The percentage discount on the subscription
     * @type {number}
     * @memberof SubscriptionServiceCoupon
     */
    'discount_percentage'?: number | null;
}

export const SubscriptionServiceCouponChargeInstanceEnum = {
    OneTime: 'one_time',
    Recurring: 'recurring'
} as const;

export type SubscriptionServiceCouponChargeInstanceEnum = typeof SubscriptionServiceCouponChargeInstanceEnum[keyof typeof SubscriptionServiceCouponChargeInstanceEnum];
export const SubscriptionServiceCouponTypeEnum = {
    FlatRate: 'flat_rate',
    Percentage: 'percentage'
} as const;

export type SubscriptionServiceCouponTypeEnum = typeof SubscriptionServiceCouponTypeEnum[keyof typeof SubscriptionServiceCouponTypeEnum];

/**
 * The pricing structure for the first charge of the subscription
 * @export
 * @interface SubscriptionServiceInitialPrice
 */
export interface SubscriptionServiceInitialPrice {
    /**
     * The initial price (in cents) excluding discount, taxes and shipping fees
     * @type {number}
     * @memberof SubscriptionServiceInitialPrice
     */
    'subtotal'?: number;
    /**
     * The initial tax fees (in cents)
     * @type {number}
     * @memberof SubscriptionServiceInitialPrice
     */
    'taxes'?: number;
    /**
     * The initial shipping fees (in cents)
     * @type {number}
     * @memberof SubscriptionServiceInitialPrice
     */
    'shipping'?: number;
    /**
     * The initial price (in cents) including discount, taxes and shipping fees
     * @type {number}
     * @memberof SubscriptionServiceInitialPrice
     */
    'total'?: number;
}
/**
 * The pricing structure for all the recurring charges of the subscription
 * @export
 * @interface SubscriptionServiceRecurringPrice
 */
export interface SubscriptionServiceRecurringPrice {
    /**
     * The recurring price (in cents) excluding discount, taxes and shipping fees
     * @type {number}
     * @memberof SubscriptionServiceRecurringPrice
     */
    'subtotal'?: number;
    /**
     * The recurring tax fees (in cents)
     * @type {number}
     * @memberof SubscriptionServiceRecurringPrice
     */
    'taxes'?: number;
    /**
     * The recurring shipping fees (in cents)
     * @type {number}
     * @memberof SubscriptionServiceRecurringPrice
     */
    'shipping'?: number;
    /**
     * The recurring price (in cents) including discount, taxes and shipping fees
     * @type {number}
     * @memberof SubscriptionServiceRecurringPrice
     */
    'total'?: number;
}

/**
 * ChargesApi - axios parameter creator
 * @export
 */
export const ChargesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a charge
         * @param {number} id The SamCart ID for the charge
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByChargeId: async (id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getByChargeId', 'id', id)
            const localVarPath = `/charges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all charges
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharges: async (createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/charges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all refunds on a charge
         * @param {number} id The SamCart ID for the charge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleRefundsByChargeId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getMultipleRefundsByChargeId', 'id', id)
            const localVarPath = `/charges/{id}/refunds`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a refund on a charge
         * @param {number} id The SamCart ID for the charge
         * @param {number} refundId The SamCart ID for the refund
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefundByChargeId: async (id: number, refundId: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getRefundByChargeId', 'id', id)
            // verify required parameter 'refundId' is not null or undefined
            assertParamExists('getRefundByChargeId', 'refundId', refundId)
            const localVarPath = `/charges/{id}/refunds/{refund_id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)))
                .replace(`{${"refund_id"}}`, encodeURIComponent(String(refundId)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ChargesApi - functional programming interface
 * @export
 */
export const ChargesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ChargesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a charge
         * @param {number} id The SamCart ID for the charge
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByChargeId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ChargeService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByChargeId(id, createdAtMin, createdAtMax, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all charges
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCharges(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse200>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCharges(createdAtMin, createdAtMax, testMode, offset, limit, dir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all refunds on a charge
         * @param {number} id The SamCart ID for the charge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getMultipleRefundsByChargeId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<RefundService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getMultipleRefundsByChargeId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a refund on a charge
         * @param {number} id The SamCart ID for the charge
         * @param {number} refundId The SamCart ID for the refund
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getRefundByChargeId(id: number, refundId: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<RefundService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getRefundByChargeId(id, refundId, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ChargesApi - factory interface
 * @export
 */
export const ChargesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ChargesApiFp(configuration)
    return {
        /**
         * Retrieve a charge
         * @param {number} id The SamCart ID for the charge
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByChargeId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: any): AxiosPromise<ChargeService> {
            return localVarFp.getByChargeId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all charges
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCharges(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: any): AxiosPromise<InlineResponse200> {
            return localVarFp.getCharges(createdAtMin, createdAtMax, testMode, offset, limit, dir, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all refunds on a charge
         * @param {number} id The SamCart ID for the charge
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getMultipleRefundsByChargeId(id: number, options?: any): AxiosPromise<Array<RefundService>> {
            return localVarFp.getMultipleRefundsByChargeId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a refund on a charge
         * @param {number} id The SamCart ID for the charge
         * @param {number} refundId The SamCart ID for the refund
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getRefundByChargeId(id: number, refundId: number, options?: any): AxiosPromise<RefundService> {
            return localVarFp.getRefundByChargeId(id, refundId, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ChargesApi - object-oriented interface
 * @export
 * @class ChargesApi
 * @extends {BaseAPI}
 */
export class ChargesApi extends BaseAPI {
    /**
     * Retrieve a charge
     * @param {number} id The SamCart ID for the charge
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargesApi
     */
    public getByChargeId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig) {
        return ChargesApiFp(this.configuration).getByChargeId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all charges
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
     * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
     * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargesApi
     */
    public getCharges(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig) {
        return ChargesApiFp(this.configuration).getCharges(createdAtMin, createdAtMax, testMode, offset, limit, dir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all refunds on a charge
     * @param {number} id The SamCart ID for the charge
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargesApi
     */
    public getMultipleRefundsByChargeId(id: number, options?: AxiosRequestConfig) {
        return ChargesApiFp(this.configuration).getMultipleRefundsByChargeId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a refund on a charge
     * @param {number} id The SamCart ID for the charge
     * @param {number} refundId The SamCart ID for the refund
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ChargesApi
     */
    public getRefundByChargeId(id: number, refundId: number, options?: AxiosRequestConfig) {
        return ChargesApiFp(this.configuration).getRefundByChargeId(id, refundId, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * CustomersApi - axios parameter creator
 * @export
 */
export const CustomersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve all addresses for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesByCustomerId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getAddressesByCustomerId', 'id', id)
            const localVarPath = `/customers/{id}/addresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByCustomerId: async (id: number, createdAtMin?: string, createdAtMax?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getByCustomerId', 'id', id)
            const localVarPath = `/customers/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all charges for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesByCustomerId: async (id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChargesByCustomerId', 'id', id)
            const localVarPath = `/customers/{id}/charges`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all customers
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers: async (createdAtMin?: string, createdAtMax?: string, offset?: number, limit?: number, dir?: 'next' | 'prev', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/customers`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all orders for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByCustomerId: async (id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getOrdersByCustomerId', 'id', id)
            const localVarPath = `/customers/{id}/orders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all subscriptions for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionsByCustomerId: async (id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionsByCustomerId', 'id', id)
            const localVarPath = `/customers/{id}/subscriptions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (rebillingAtMin !== undefined) {
                localVarQueryParameter['rebilling_at_min'] = (rebillingAtMin as any instanceof Date) ?
                    (rebillingAtMin as any).toISOString().substr(0,10) :
                    rebillingAtMin;
            }

            if (rebillingAtMax !== undefined) {
                localVarQueryParameter['rebilling_at_max'] = (rebillingAtMax as any instanceof Date) ?
                    (rebillingAtMax as any).toISOString().substr(0,10) :
                    rebillingAtMax;
            }

            if (canceledAtMin !== undefined) {
                localVarQueryParameter['canceled_at_min'] = (canceledAtMin as any instanceof Date) ?
                    (canceledAtMin as any).toISOString().substr(0,10) :
                    canceledAtMin;
            }

            if (canceledAtMax !== undefined) {
                localVarQueryParameter['canceled_at_max'] = (canceledAtMax as any instanceof Date) ?
                    (canceledAtMax as any).toISOString().substr(0,10) :
                    canceledAtMax;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CustomersApi - functional programming interface
 * @export
 */
export const CustomersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = CustomersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve all addresses for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getAddressesByCustomerId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<AddressService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getAddressesByCustomerId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByCustomerId(id, createdAtMin, createdAtMax, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all charges for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargesByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChargeService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargesByCustomerId(id, createdAtMin, createdAtMax, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all customers
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomers(createdAtMin?: string, createdAtMax?: string, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2001>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomers(createdAtMin, createdAtMax, offset, limit, dir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all orders for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrdersByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<OrderService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrdersByCustomerId(id, createdAtMin, createdAtMax, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all subscriptions for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionsByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionsByCustomerId(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, status, type, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * CustomersApi - factory interface
 * @export
 */
export const CustomersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = CustomersApiFp(configuration)
    return {
        /**
         * Retrieve all addresses for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAddressesByCustomerId(id: number, options?: any): AxiosPromise<Array<AddressService>> {
            return localVarFp.getAddressesByCustomerId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, options?: any): AxiosPromise<CustomerService> {
            return localVarFp.getByCustomerId(id, createdAtMin, createdAtMax, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all charges for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: any): AxiosPromise<Array<ChargeService>> {
            return localVarFp.getChargesByCustomerId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all customers
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomers(createdAtMin?: string, createdAtMax?: string, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: any): AxiosPromise<InlineResponse2001> {
            return localVarFp.getCustomers(createdAtMin, createdAtMax, offset, limit, dir, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all orders for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrdersByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: any): AxiosPromise<Array<OrderService>> {
            return localVarFp.getOrdersByCustomerId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all subscriptions for a customer
         * @param {number} id The SamCart ID for the customer
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionsByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', testMode?: boolean, options?: any): AxiosPromise<Array<SubscriptionService>> {
            return localVarFp.getSubscriptionsByCustomerId(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, status, type, testMode, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * CustomersApi - object-oriented interface
 * @export
 * @class CustomersApi
 * @extends {BaseAPI}
 */
export class CustomersApi extends BaseAPI {
    /**
     * Retrieve all addresses for a customer
     * @param {number} id The SamCart ID for the customer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getAddressesByCustomerId(id: number, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getAddressesByCustomerId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a customer
     * @param {number} id The SamCart ID for the customer
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getByCustomerId(id, createdAtMin, createdAtMax, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all charges for a customer
     * @param {number} id The SamCart ID for the customer
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getChargesByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getChargesByCustomerId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all customers
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
     * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
     * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getCustomers(createdAtMin?: string, createdAtMax?: string, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getCustomers(createdAtMin, createdAtMax, offset, limit, dir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all orders for a customer
     * @param {number} id The SamCart ID for the customer
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getOrdersByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getOrdersByCustomerId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all subscriptions for a customer
     * @param {number} id The SamCart ID for the customer
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
     * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
     * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
     * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
     * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
     * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CustomersApi
     */
    public getSubscriptionsByCustomerId(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', testMode?: boolean, options?: AxiosRequestConfig) {
        return CustomersApiFp(this.configuration).getSubscriptionsByCustomerId(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, status, type, testMode, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * FailedChargesApi - axios parameter creator
 * @export
 */
export const FailedChargesApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a failed charge
         * @param {number} id The SamCart ID for the charge
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByFailedChargeId: async (id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getByFailedChargeId', 'id', id)
            const localVarPath = `/failed-charges/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all failed charges
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailedCharges: async (createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/failed-charges`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FailedChargesApi - functional programming interface
 * @export
 */
export const FailedChargesApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = FailedChargesApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a failed charge
         * @param {number} id The SamCart ID for the charge
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByFailedChargeId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<FailedChargeService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByFailedChargeId(id, createdAtMin, createdAtMax, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all failed charges
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getFailedCharges(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2002>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getFailedCharges(createdAtMin, createdAtMax, testMode, offset, limit, dir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * FailedChargesApi - factory interface
 * @export
 */
export const FailedChargesApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = FailedChargesApiFp(configuration)
    return {
        /**
         * Retrieve a failed charge
         * @param {number} id The SamCart ID for the charge
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByFailedChargeId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: any): AxiosPromise<FailedChargeService> {
            return localVarFp.getByFailedChargeId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all failed charges
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFailedCharges(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: any): AxiosPromise<InlineResponse2002> {
            return localVarFp.getFailedCharges(createdAtMin, createdAtMax, testMode, offset, limit, dir, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * FailedChargesApi - object-oriented interface
 * @export
 * @class FailedChargesApi
 * @extends {BaseAPI}
 */
export class FailedChargesApi extends BaseAPI {
    /**
     * Retrieve a failed charge
     * @param {number} id The SamCart ID for the charge
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FailedChargesApi
     */
    public getByFailedChargeId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig) {
        return FailedChargesApiFp(this.configuration).getByFailedChargeId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all failed charges
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
     * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
     * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FailedChargesApi
     */
    public getFailedCharges(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig) {
        return FailedChargesApiFp(this.configuration).getFailedCharges(createdAtMin, createdAtMax, testMode, offset, limit, dir, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * OrdersApi - axios parameter creator
 * @export
 */
export const OrdersApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByOrderId: async (id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getByOrderId', 'id', id)
            const localVarPath = `/orders/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all charges on an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesByOrderId: async (id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChargesByOrderId', 'id', id)
            const localVarPath = `/orders/{id}/charges`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve customer on an order
         * @param {number} id The SamCart ID for the order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByOrderId: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomerByOrderId', 'id', id)
            const localVarPath = `/orders/{id}/customer`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all orders
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders: async (createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/orders`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all subscriptions on an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionsByOrderId: async (id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionsByOrderId', 'id', id)
            const localVarPath = `/orders/{id}/subscriptions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (rebillingAtMin !== undefined) {
                localVarQueryParameter['rebilling_at_min'] = (rebillingAtMin as any instanceof Date) ?
                    (rebillingAtMin as any).toISOString().substr(0,10) :
                    rebillingAtMin;
            }

            if (rebillingAtMax !== undefined) {
                localVarQueryParameter['rebilling_at_max'] = (rebillingAtMax as any instanceof Date) ?
                    (rebillingAtMax as any).toISOString().substr(0,10) :
                    rebillingAtMax;
            }

            if (canceledAtMin !== undefined) {
                localVarQueryParameter['canceled_at_min'] = (canceledAtMin as any instanceof Date) ?
                    (canceledAtMin as any).toISOString().substr(0,10) :
                    canceledAtMin;
            }

            if (canceledAtMax !== undefined) {
                localVarQueryParameter['canceled_at_max'] = (canceledAtMax as any instanceof Date) ?
                    (canceledAtMax as any).toISOString().substr(0,10) :
                    canceledAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrdersApi - functional programming interface
 * @export
 */
export const OrdersApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = OrdersApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<OrderService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByOrderId(id, createdAtMin, createdAtMax, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all charges on an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargesByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChargeService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargesByOrderId(id, createdAtMin, createdAtMax, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve customer on an order
         * @param {number} id The SamCart ID for the order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerByOrderId(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerByOrderId(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all orders
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getOrders(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2003>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getOrders(createdAtMin, createdAtMax, testMode, offset, limit, dir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all subscriptions on an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionsByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionsByOrderId(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * OrdersApi - factory interface
 * @export
 */
export const OrdersApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = OrdersApiFp(configuration)
    return {
        /**
         * Retrieve an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: any): AxiosPromise<OrderService> {
            return localVarFp.getByOrderId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all charges on an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: any): AxiosPromise<Array<ChargeService>> {
            return localVarFp.getChargesByOrderId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve customer on an order
         * @param {number} id The SamCart ID for the order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerByOrderId(id: number, options?: any): AxiosPromise<CustomerService> {
            return localVarFp.getCustomerByOrderId(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all orders
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: any): AxiosPromise<InlineResponse2003> {
            return localVarFp.getOrders(createdAtMin, createdAtMax, testMode, offset, limit, dir, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all subscriptions on an order
         * @param {number} id The SamCart ID for the order
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionsByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options?: any): AxiosPromise<Array<SubscriptionService>> {
            return localVarFp.getSubscriptionsByOrderId(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * OrdersApi - object-oriented interface
 * @export
 * @class OrdersApi
 * @extends {BaseAPI}
 */
export class OrdersApi extends BaseAPI {
    /**
     * Retrieve an order
     * @param {number} id The SamCart ID for the order
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getByOrderId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all charges on an order
     * @param {number} id The SamCart ID for the order
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getChargesByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getChargesByOrderId(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve customer on an order
     * @param {number} id The SamCart ID for the order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getCustomerByOrderId(id: number, options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getCustomerByOrderId(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all orders
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
     * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
     * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getOrders(createdAtMin?: string, createdAtMax?: string, testMode?: boolean, offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getOrders(createdAtMin, createdAtMax, testMode, offset, limit, dir, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all subscriptions on an order
     * @param {number} id The SamCart ID for the order
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
     * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
     * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
     * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
     * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrdersApi
     */
    public getSubscriptionsByOrderId(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options?: AxiosRequestConfig) {
        return OrdersApiFp(this.configuration).getSubscriptionsByOrderId(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * ProductsApi - axios parameter creator
 * @export
 */
export const ProductsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve a product
         * @param {number} id The SamCart ID for the product
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {'live' | 'test' | 'archived'} [status] Filter product by status
         * @param {'physical' | 'digital'} [productCategory] Filter product by category
         * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByProductId: async (id: number, createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getByProductId', 'id', id)
            const localVarPath = `/products/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (productCategory !== undefined) {
                localVarQueryParameter['product_category'] = productCategory;
            }

            if (pricingType !== undefined) {
                localVarQueryParameter['pricing_type'] = pricingType;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all products
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {'live' | 'test' | 'archived'} [status] Filter product by status
         * @param {'physical' | 'digital'} [productCategory] Filter product by category
         * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts: async (createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/products`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (productCategory !== undefined) {
                localVarQueryParameter['product_category'] = productCategory;
            }

            if (pricingType !== undefined) {
                localVarQueryParameter['pricing_type'] = pricingType;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ProductsApi - functional programming interface
 * @export
 */
export const ProductsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = ProductsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve a product
         * @param {number} id The SamCart ID for the product
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {'live' | 'test' | 'archived'} [status] Filter product by status
         * @param {'physical' | 'digital'} [productCategory] Filter product by category
         * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getByProductId(id: number, createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<ProductService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getByProductId(id, createdAtMin, createdAtMax, status, productCategory, pricingType, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all products
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {'live' | 'test' | 'archived'} [status] Filter product by status
         * @param {'physical' | 'digital'} [productCategory] Filter product by category
         * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getProducts(createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2004>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getProducts(createdAtMin, createdAtMax, status, productCategory, pricingType, offset, limit, dir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * ProductsApi - factory interface
 * @export
 */
export const ProductsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = ProductsApiFp(configuration)
    return {
        /**
         * Retrieve a product
         * @param {number} id The SamCart ID for the product
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {'live' | 'test' | 'archived'} [status] Filter product by status
         * @param {'physical' | 'digital'} [productCategory] Filter product by category
         * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getByProductId(id: number, createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', options?: any): AxiosPromise<ProductService> {
            return localVarFp.getByProductId(id, createdAtMin, createdAtMax, status, productCategory, pricingType, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all products
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {'live' | 'test' | 'archived'} [status] Filter product by status
         * @param {'physical' | 'digital'} [productCategory] Filter product by category
         * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getProducts(createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options?: any): AxiosPromise<InlineResponse2004> {
            return localVarFp.getProducts(createdAtMin, createdAtMax, status, productCategory, pricingType, offset, limit, dir, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * ProductsApi - object-oriented interface
 * @export
 * @class ProductsApi
 * @extends {BaseAPI}
 */
export class ProductsApi extends BaseAPI {
    /**
     * Retrieve a product
     * @param {number} id The SamCart ID for the product
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {'live' | 'test' | 'archived'} [status] Filter product by status
     * @param {'physical' | 'digital'} [productCategory] Filter product by category
     * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getByProductId(id: number, createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getByProductId(id, createdAtMin, createdAtMax, status, productCategory, pricingType, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all products
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {'live' | 'test' | 'archived'} [status] Filter product by status
     * @param {'physical' | 'digital'} [productCategory] Filter product by category
     * @param {'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription'} [pricingType] Filter product by pricing type
     * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
     * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
     * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ProductsApi
     */
    public getProducts(createdAtMin?: string, createdAtMax?: string, status?: 'live' | 'test' | 'archived', productCategory?: 'physical' | 'digital', pricingType?: 'one_time' | 'limited_subscription' | 'recurring_subscription' | 'pwyw_one_time' | 'pwyw_recurring_subscription' | 'pwyw_limited_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig) {
        return ProductsApiFp(this.configuration).getProducts(createdAtMin, createdAtMax, status, productCategory, pricingType, offset, limit, dir, options).then((request) => request(this.axios, this.basePath));
    }
}


/**
 * SubscriptionsApi - axios parameter creator
 * @export
 */
export const SubscriptionsApiAxiosParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Retrieve charges on a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesBySubscriptionID: async (id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getChargesBySubscriptionID', 'id', id)
            const localVarPath = `/subscriptions/{id}/charges`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a customer on a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBySubscriptionID: async (id: number, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getCustomerBySubscriptionID', 'id', id)
            const localVarPath = `/subscriptions/{id}/customer`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a subscription\'s history
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoriesBySubscriptionID: async (id: number, createdAtMin?: string, createdAtMax?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getHistoriesBySubscriptionID', 'id', id)
            const localVarPath = `/subscriptions/{id}/history`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a plan for a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanBySubscriptionID: async (id: number, createdAtMin?: string, createdAtMax?: string, options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getPlanBySubscriptionID', 'id', id)
            const localVarPath = `/subscriptions/{id}/plan`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionById: async (id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            // verify required parameter 'id' is not null or undefined
            assertParamExists('getSubscriptionById', 'id', id)
            const localVarPath = `/subscriptions/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (rebillingAtMin !== undefined) {
                localVarQueryParameter['rebilling_at_min'] = (rebillingAtMin as any instanceof Date) ?
                    (rebillingAtMin as any).toISOString().substr(0,10) :
                    rebillingAtMin;
            }

            if (rebillingAtMax !== undefined) {
                localVarQueryParameter['rebilling_at_max'] = (rebillingAtMax as any instanceof Date) ?
                    (rebillingAtMax as any).toISOString().substr(0,10) :
                    rebillingAtMax;
            }

            if (canceledAtMin !== undefined) {
                localVarQueryParameter['canceled_at_min'] = (canceledAtMin as any instanceof Date) ?
                    (canceledAtMin as any).toISOString().substr(0,10) :
                    canceledAtMin;
            }

            if (canceledAtMax !== undefined) {
                localVarQueryParameter['canceled_at_max'] = (canceledAtMax as any instanceof Date) ?
                    (canceledAtMax as any).toISOString().substr(0,10) :
                    canceledAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Retrieve all subscriptions
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions: async (createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options: AxiosRequestConfig = {}): Promise<RequestArgs> => {
            const localVarPath = `/subscriptions`;
            // use dummy base URL string because the URL constructor only accepts absolute URLs.
            const localVarUrlObj = new URL(localVarPath, DUMMY_BASE_URL);
            let baseOptions;
            if (configuration) {
                baseOptions = configuration.baseOptions;
            }

            const localVarRequestOptions = { method: 'GET', ...baseOptions, ...options};
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication apiKeyAuth required
            await setApiKeyToObject(localVarHeaderParameter, "sc-api", configuration)

            if (createdAtMin !== undefined) {
                localVarQueryParameter['created_at_min'] = (createdAtMin as any instanceof Date) ?
                    (createdAtMin as any).toISOString().substr(0,10) :
                    createdAtMin;
            }

            if (createdAtMax !== undefined) {
                localVarQueryParameter['created_at_max'] = (createdAtMax as any instanceof Date) ?
                    (createdAtMax as any).toISOString().substr(0,10) :
                    createdAtMax;
            }

            if (rebillingAtMin !== undefined) {
                localVarQueryParameter['rebilling_at_min'] = (rebillingAtMin as any instanceof Date) ?
                    (rebillingAtMin as any).toISOString().substr(0,10) :
                    rebillingAtMin;
            }

            if (rebillingAtMax !== undefined) {
                localVarQueryParameter['rebilling_at_max'] = (rebillingAtMax as any instanceof Date) ?
                    (rebillingAtMax as any).toISOString().substr(0,10) :
                    rebillingAtMax;
            }

            if (canceledAtMin !== undefined) {
                localVarQueryParameter['canceled_at_min'] = (canceledAtMin as any instanceof Date) ?
                    (canceledAtMin as any).toISOString().substr(0,10) :
                    canceledAtMin;
            }

            if (canceledAtMax !== undefined) {
                localVarQueryParameter['canceled_at_max'] = (canceledAtMax as any instanceof Date) ?
                    (canceledAtMax as any).toISOString().substr(0,10) :
                    canceledAtMax;
            }

            if (testMode !== undefined) {
                localVarQueryParameter['test_mode'] = testMode;
            }

            if (status !== undefined) {
                localVarQueryParameter['status'] = status;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (dir !== undefined) {
                localVarQueryParameter['dir'] = dir;
            }


    
            setSearchParams(localVarUrlObj, localVarQueryParameter);
            let headersFromBaseOptions = baseOptions && baseOptions.headers ? baseOptions.headers : {};
            localVarRequestOptions.headers = {...localVarHeaderParameter, ...headersFromBaseOptions, ...options.headers};

            return {
                url: toPathString(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionsApi - functional programming interface
 * @export
 */
export const SubscriptionsApiFp = function(configuration?: Configuration) {
    const localVarAxiosParamCreator = SubscriptionsApiAxiosParamCreator(configuration)
    return {
        /**
         * Retrieve charges on a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getChargesBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<ChargeService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getChargesBySubscriptionID(id, createdAtMin, createdAtMax, testMode, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a customer on a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getCustomerBySubscriptionID(id: number, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<CustomerService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getCustomerBySubscriptionID(id, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a subscription\'s history
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getHistoriesBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<Array<SubscriptionHistoryService>>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getHistoriesBySubscriptionID(id, createdAtMin, createdAtMax, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a plan for a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getPlanBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionPlanService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getPlanBySubscriptionID(id, createdAtMin, createdAtMax, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptionById(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<SubscriptionService>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptionById(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
        /**
         * Retrieve all subscriptions
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        async getSubscriptions(createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig): Promise<(axios?: AxiosInstance, basePath?: string) => AxiosPromise<InlineResponse2005>> {
            const localVarAxiosArgs = await localVarAxiosParamCreator.getSubscriptions(createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, offset, limit, dir, options);
            return createRequestFunction(localVarAxiosArgs, globalAxios, BASE_PATH, configuration);
        },
    }
};

/**
 * SubscriptionsApi - factory interface
 * @export
 */
export const SubscriptionsApiFactory = function (configuration?: Configuration, basePath?: string, axios?: AxiosInstance) {
    const localVarFp = SubscriptionsApiFp(configuration)
    return {
        /**
         * Retrieve charges on a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getChargesBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: any): AxiosPromise<Array<ChargeService>> {
            return localVarFp.getChargesBySubscriptionID(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a customer on a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCustomerBySubscriptionID(id: number, options?: any): AxiosPromise<CustomerService> {
            return localVarFp.getCustomerBySubscriptionID(id, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a subscription\'s history
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getHistoriesBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, options?: any): AxiosPromise<Array<SubscriptionHistoryService>> {
            return localVarFp.getHistoriesBySubscriptionID(id, createdAtMin, createdAtMax, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a plan for a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlanBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, options?: any): AxiosPromise<SubscriptionPlanService> {
            return localVarFp.getPlanBySubscriptionID(id, createdAtMin, createdAtMax, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve a subscription
         * @param {number} id The SamCart ID for the subscription
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionById(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options?: any): AxiosPromise<SubscriptionService> {
            return localVarFp.getSubscriptionById(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, options).then((request) => request(axios, basePath));
        },
        /**
         * Retrieve all subscriptions
         * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
         * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
         * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
         * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
         * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
         * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
         * @param {boolean} [testMode] Filter by test mode
         * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
         * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
         * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
         * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
         * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptions(createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options?: any): AxiosPromise<InlineResponse2005> {
            return localVarFp.getSubscriptions(createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, offset, limit, dir, options).then((request) => request(axios, basePath));
        },
    };
};

/**
 * SubscriptionsApi - object-oriented interface
 * @export
 * @class SubscriptionsApi
 * @extends {BaseAPI}
 */
export class SubscriptionsApi extends BaseAPI {
    /**
     * Retrieve charges on a subscription
     * @param {number} id The SamCart ID for the subscription
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getChargesBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, testMode?: boolean, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getChargesBySubscriptionID(id, createdAtMin, createdAtMax, testMode, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a customer on a subscription
     * @param {number} id The SamCart ID for the subscription
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getCustomerBySubscriptionID(id: number, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getCustomerBySubscriptionID(id, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a subscription\'s history
     * @param {number} id The SamCart ID for the subscription
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getHistoriesBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getHistoriesBySubscriptionID(id, createdAtMin, createdAtMax, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a plan for a subscription
     * @param {number} id The SamCart ID for the subscription
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getPlanBySubscriptionID(id: number, createdAtMin?: string, createdAtMax?: string, options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getPlanBySubscriptionID(id, createdAtMin, createdAtMax, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve a subscription
     * @param {number} id The SamCart ID for the subscription
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
     * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
     * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
     * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
     * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptionById(id: number, createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getSubscriptionById(id, createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, options).then((request) => request(this.axios, this.basePath));
    }

    /**
     * Retrieve all subscriptions
     * @param {string} [createdAtMin] Filter by UTC created at date at or after given date
     * @param {string} [createdAtMax] Filter by UTC created at date at or before given date
     * @param {string} [rebillingAtMin] Filter by UTC rebilling date at or after given date
     * @param {string} [rebillingAtMax] Filter by UTC rebilling date at or before given date
     * @param {string} [canceledAtMin] Filter by UTC canceled date at or after given date
     * @param {string} [canceledAtMax] Filter by UTC canceled date at or before given date
     * @param {boolean} [testMode] Filter by test mode
     * @param {'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted'} [status] Filter subscriptions by status
     * @param {'limited_subscription' | 'recurring_subscription'} [type] Filter subscriptions by type
     * @param {number} [offset] The offset value used to paginate through a list of entries. If the dir query parameter is prev then the offset will be the id of the first record of the data set otherwise the offset will be the id of the last record
     * @param {number} [limit] An optional limit for the number of entries on a page with a maximum value of 100. Default value is 100 if not provided.
     * @param {'next' | 'prev'} [dir] The direction to paginate the next set of data. If dir is prev the page will return a data set before the offset otherwise the data set will be after the offset. Default value is next if not provided.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionsApi
     */
    public getSubscriptions(createdAtMin?: string, createdAtMax?: string, rebillingAtMin?: string, rebillingAtMax?: string, canceledAtMin?: string, canceledAtMax?: string, testMode?: boolean, status?: 'active' | 'canceled' | 'delinquent' | 'completed' | 'paused' | 'invalid_processor' | 'sca_required' | 'deleted', type?: 'limited_subscription' | 'recurring_subscription', offset?: number, limit?: number, dir?: 'next' | 'prev', options?: AxiosRequestConfig) {
        return SubscriptionsApiFp(this.configuration).getSubscriptions(createdAtMin, createdAtMax, rebillingAtMin, rebillingAtMax, canceledAtMin, canceledAtMax, testMode, status, type, offset, limit, dir, options).then((request) => request(this.axios, this.basePath));
    }
}


